# === compare_backups.py ===
# Compares two backups generated by backup.py and prints the songs and albums only present in the earlier backup

from backup import back_up, load_backup
from fix_unavailable import log_in
import argparse
from datetime import datetime


def build_parser():
    parser = argparse.ArgumentParser(
        description="Compares two backups generated by backup.py and prints the songs and albums only present in the earlier backup")
    parser.add_argument('backup_old', help='The older backup file')
    parser.add_argument('backup_new', nargs='?', help='The newer backup file; if not provided, a new backup will be generated')
    return parser


def compare_backups(args, backup_old, backup_new):
    [tracks_old, albums_old, _] = load_backup(backup_old)
    [tracks_new, albums_new, _] = load_backup(backup_new)
    removed_albums = compare_albums(albums_old, albums_new)
    removed_tracks = compare_tracks(tracks_old, tracks_new)
    if removed_albums:
        removed_albums.sort(key=lambda x: (x.artist.name, x.album.name))
    print_removed_albums(removed_albums)
    if removed_tracks:
        removed_tracks.sort(key=lambda x: (x.artist.name, x.album.name))
    print_removed_tracks(removed_tracks)
    
        
def print_removed_albums(removed_albums):
    print("Albums present in old backup & not present in new backup (match: name, artist):\n")
    if not removed_albums:
        print("None")
    else:
        for album in removed_albums:
            print("{}: '{}' by '{}'".format(album.id, album.name, album.artist.name))
    print()


def print_removed_tracks(removed_tracks):
    print("Tracks present in old backup & not present in new backup (match: name, artist):\n")
    if not removed_tracks:
        print("None")
    else:
        for track in removed_tracks:
            print("{}: '{}' by '{}'".format(track.id, track.full_name, track.artist.name))
    print()
    

def compare_albums(albums_old, albums_new):    
    removed_albums = []
    for album_old in albums_old:
        for i, album_new in enumerate(albums_new):
            # Search criteria can be simple here because in theory anything already in our library won't have changed
            if album_old.name.casefold() == album_new.name.casefold() and \
                    album_old.artist.name.casefold() == album_new.artist.name.casefold():
                break
            elif i == len(albums_new) - 1:
                removed_albums.append(album_old)
                
    
def compare_tracks(tracks_old, tracks_new):
    removed_tracks = []
    for track_old in tracks_old:
        for i, track_new in enumerate(tracks_new):
            # Search criteria can be simple here because in theory anything already in our library won't have changed
            if track_old.full_name.casefold() == track_new.full_name.casefold() and \
                    track_old.artist.name.casefold() == track_new.artist.name.casefold():
                break
            elif i == len(tracks_new) - 1:
                removed_tracks.append(track_old)
    return removed_tracks


def main():
    # Read the command line arguments
    parser = build_parser()
    args = parser.parse_args()
        
    # Create a new backup first if necessary
    if not args.backup_new:
        session = log_in()
        date_suffix = datetime.today().strftime('%Y-%m-%d_%H%M%S')
        args.backup_new = 'library_backup_' + date_suffix + '.pkl'
        back_up(session, args.backup_new)

    # Compare the provided backups
    compare_backups(args, args.backup_old, args.backup_new)


if __name__ == '__main__':
    main()
